classdef Map < handle
    properties
        size_x;
        size_y;
        size
        course_data;
        grid;
        binary_grid
        shorter_path_grid
        start_x;
        start_y;
        goal_x;
        goal_y;
        open_list = [];
    end
    methods
        function obj = Map(course_data, expantion) % x, y座標の行列　単位はcmにしたい
            obj.size_x = max(course_data(1, :)) - min(course_data(1, :)) + 1; % xのベクトルの最大値-最小値でマップのx方向サイズを計算 
            obj.size_y = max(course_data(2, :)) - min(course_data(2, :)) + 1; % yのベクトルの最大値-最小値でマップのy方向サイズを計算 
            obj.size = obj.size_x * obj.size_y;
            obj.course_data = course_data;
            [obj.grid, obj.binary_grid] = createMap(obj.size_x, obj.size_y, obj.course_data, expantion);
            obj.shorter_path_grid = obj.binary_grid;
            
            if course_data(1, 1) < 1
                obj.start_x = 1;
            else
                obj.start_x = course_data(1, 1);
            end
            if course_data(2, 1) > obj.size_y
               obj.start_y =  obj.size_y;   
            else 
                obj.start_y = course_data(2, 1);
            end
                
            if course_data(1, end) < 1
                obj.goal_x = 1;
            else
                obj.goal_x = course_data(1, end);
            end
            if course_data(2, end) > obj.size_y
               obj.goal_y =  obj.size_y;   
            else 
               obj.goal_y = course_data(2, end);
            end
            
%             obj.start_x = course_data(1, 1);
%             obj.start_y = course_data(2, 1);
%             obj.goal_x = course_data(1, end);
%             obj.goal_y = course_data(2, end);
        end
        
        function calcScore(obj, x, y, g_cost)
            obj.grid(y, x).g_cost = g_cost;
            obj.grid(y, x).h_cost = obj.goal_x - x + obj.goal_y - y;
            obj.grid(y, x).score = obj.grid(y, x).g_cost + obj.grid(y, x).h_cost;
        end
        
        function openAroundNode(obj, ref_x, ref_y, g_cost)
            for i = -1 : 1
                x = ref_x + i;
                if x < 1
                    x = 1;
                elseif x > obj.size_x
                    x = obj.size_x;
                end
                
                for j =  -1 : 1
                    y = ref_y + j;
                    if y < 1
                        y = 1;
                    elseif y > obj.size_y
                        y = obj.size_y;
                    end
                    
                    if obj.grid(y, x).obstacle == 0 && obj.grid(y, x).status == 0 && ~(ref_x == x && ref_y == y) % 移動可能 かつ 状態がNone かつ 基準ノードでない
                        obj.grid(y, x).status = 1; % open
                        obj.calcScore(x, y, g_cost) % コストを計算
                        
                        temp_node.x = x;
                        temp_node.y = y;
                        temp_node.score = obj.grid(y, x).score;
                        temp_node.g_cost = obj.grid(y, x).g_cost;
                        obj.open_list = [obj.open_list, temp_node]; %オープンリストに追加
                        
                        obj.grid(y, x).parent = [ref_x, ref_y]; %親ノードの位置を保存
  
                    end
                    
                    obj.grid(ref_y, ref_x).status = -1; %基準ノードをクローズ
                    obj.deleteOpenList(ref_x, ref_y) %オープンリストからクローズした基準ノードを削除
                end
                
                
            end
 
        end

        function [ref_x, ref_y] = searchRefNode(obj)     
            scores = zeros(1, length(obj.open_list));
            
            for i = 1 : length(obj.open_list)
                scores(i) = obj.open_list(i).score;
            end
            
            minimum = min(min(scores));
            index = find(scores == minimum); % 最小スコアのインデックスを取得
            
            if length(index) > 1 %最小のコストが複数あったら
                for j = 1 : length(index)
                    obj.open_list.g_cost
                end
            end

            ref_x = obj.open_list(index).x;
            ref_y = obj.open_list(index).y;

        end
        
        function deleteOpenList(obj, ref_x, ref_y)
            for i = 1 : length(obj.open_list)
                if obj.open_list(i).x == ref_x && obj.open_list(i).y == ref_y
                    obj.open_list(i) = [];
                    break;
                end
            end
        end
        
    end

       
end

function [grid, binary_grid] = createMap(x_size, y_size, course_data, expantion)
empty_grid = repmat(Node(1), y_size, x_size); % 行、列　＝　y, x
empty_binary_grid = ones(y_size, x_size); % 行、列　＝　y, x

x_datas = course_data(1, :);
y_datas = course_data(2, :);
half_expantion = round(expantion / 2);
for i = 1 : length(x_datas)
    for ex = 1 : expantion
        for ey = 1 : expantion
            x = x_datas(i) + 1 - half_expantion + ex;
            y = y_datas(i) + 1 - half_expantion + ey;

            if x < 1
               x = 1; 
            elseif x > x_size
                x = x_size;
            end
            if y < 1
               y = 1; 
            elseif y > y_size
                y = y_size;
            end

            empty_grid(y, x) = Node(0);
            empty_binary_grid(y, x) = 0;
        end
    end
end

grid = empty_grid;
binary_grid = empty_binary_grid;
%             grid = flipud(empty_grid); %上下反転する
%             binary_grid = flipud(empty_binary_grid);

end

    